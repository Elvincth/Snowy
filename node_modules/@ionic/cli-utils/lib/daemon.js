"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const config_1 = require("./config");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const plugins_1 = require("./plugins");
const KNOWN_PACKAGES = [
    ...[].concat(plugins_1.KNOWN_PLUGINS).map(plugins_1.formatFullPluginName),
    '@ionic/cli-utils',
    'ionic',
];
exports.DAEMON_PID_FILE = 'daemon.pid';
exports.DAEMON_PORT_FILE = 'daemon.port';
exports.DAEMON_JSON_FILE = 'daemon.json';
exports.DAEMON_LOG_FILE = 'daemon.log';
class Daemon extends config_1.BaseConfig {
    get pidFilePath() {
        return path.join(this.directory, exports.DAEMON_PID_FILE);
    }
    get portFilePath() {
        return path.join(this.directory, exports.DAEMON_PORT_FILE);
    }
    get logFilePath() {
        return path.join(this.directory, exports.DAEMON_LOG_FILE);
    }
    getPid() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const f = yield fs_1.fsReadFile(this.pidFilePath, { encoding: 'utf8' });
                return Number(f);
            }
            catch (e) {
                if (e.code !== 'ENOENT') {
                    throw e;
                }
            }
        });
    }
    setPid(pid) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield fs_1.fsWriteFile(this.pidFilePath, String(pid), { encoding: 'utf8' });
        });
    }
    getPort() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const f = yield fs_1.fsReadFile(this.portFilePath, { encoding: 'utf8' });
                return Number(f);
            }
            catch (e) {
                if (e.code !== 'ENOENT') {
                    throw e;
                }
            }
        });
    }
    setPort(port) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield fs_1.fsWriteFile(this.portFilePath, String(port), { encoding: 'utf8' });
        });
    }
    provideDefaults(o) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const cloneDeep = yield Promise.resolve().then(() => require('lodash/cloneDeep'));
            const results = cloneDeep(o);
            if (!results.daemonVersion) {
                results.daemonVersion = '';
            }
            if (!results.latestVersions) {
                results.latestVersions = {};
            }
            if (!results.latestVersions.latest) {
                results.latestVersions.latest = {};
            }
            for (let distTag in results.latestVersions) {
                for (let pkg in results.latestVersions[distTag]) {
                    if (!KNOWN_PACKAGES.includes(pkg)) {
                        delete results.latestVersions[distTag][pkg];
                    }
                }
            }
            for (let pkg of KNOWN_PACKAGES) {
                if (typeof results.latestVersions.latest[pkg] === 'undefined') {
                    results.latestVersions.latest[pkg] = '';
                }
            }
            return results;
        });
    }
    populateDistTag(distTag) {
        if (this.configFile) {
            if (typeof this.configFile.latestVersions[distTag] === 'undefined') {
                this.configFile.latestVersions[distTag] = {};
            }
            for (let pkg of KNOWN_PACKAGES) {
                if (typeof this.configFile.latestVersions[distTag][pkg] === 'undefined') {
                    this.configFile.latestVersions[distTag][pkg] = '';
                }
            }
        }
    }
    is(j) {
        return j
            && typeof j.latestVersions === 'object'
            && typeof j.latestVersions.latest === 'object';
    }
}
exports.Daemon = Daemon;
function processRunning(pid) {
    try {
        const r = process.kill(pid, 0);
        if (typeof r === 'boolean') {
            return r;
        }
        return true;
    }
    catch (e) {
        return e.code === 'EPERM';
    }
}
exports.processRunning = processRunning;
function createCommServer(env) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const [express, bodyParser] = yield Promise.all([Promise.resolve().then(() => require('express')), Promise.resolve().then(() => require('body-parser'))]);
        const { PROJECT_FILE, Project } = yield Promise.resolve().then(() => require('../lib/project'));
        const app = express();
        app.use(bodyParser.json());
        app.post('/events/command', (req, res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { sendCommand } = yield Promise.resolve().then(() => require('./telemetry'));
            const { command, args } = req.body;
            if (typeof command !== 'string' || !args || typeof args.length !== 'number') {
                return res.sendStatus(400);
            }
            res.sendStatus(204);
            yield env.config.load({ disk: true });
            yield sendCommand(env, new Project(req.body.projectDir, PROJECT_FILE), command, args);
        }));
        return app;
    });
}
exports.createCommServer = createCommServer;
