import * as minimist from 'minimist';
import { CommandLineOptions, CommandMetadata, CommandMetadataInput, CommandMetadataOption, HydratedCommandOption, HydratedParseArgsOptions, MetadataGroup, ParsedArg } from '../definitions';
export declare const parseArgs: typeof minimist;
export { ParsedArgs } from 'minimist';
/**
 * Remove options, which are any arguments that starts with a hyphen (-), from
 * a list of process args and return the result.
 *
 * If a double-hyphen separator (--) is encountered, it and the remaining
 * arguments are included in the result, as they are not interpreted. This
 * behavior can be disabled by setting the `includeSeparated` option to
 * `false`.
 */
export declare function stripOptions(pargv: string[], {includeSeparated}: {
    includeSeparated?: boolean;
}): string[];
/**
 * Split a list of process args into own-arguments and other-arguments, which
 * are separated by the double-hyphen (--) separator.
 *
 * For example, `['cmd', 'arg1', '--', 'arg2']` will be split into
 * `['cmd', 'arg1']` and `['arg2']`.
 */
export declare function separateArgv(pargv: string[]): [string[], string[]];
/**
 * Takes a Minimist command option and normalizes its values.
 */
export declare function hydrateCommandMetadataOption<O extends CommandMetadataOption>(option: O): O & HydratedCommandOption;
export declare function metadataToParseArgsOptions(metadata: CommandMetadata): HydratedParseArgsOptions;
export declare type OptionPredicate<O extends CommandMetadataOption> = (option: O, value?: ParsedArg) => boolean;
export declare namespace OptionFilters {
    function includesGroups<O extends CommandMetadataOption>(groups: MetadataGroup | MetadataGroup[]): OptionPredicate<O>;
    function excludesGroups<O extends CommandMetadataOption>(groups: MetadataGroup | MetadataGroup[]): OptionPredicate<O>;
}
/**
 * Given a command metadata object and an object of parsed options, match each
 * supplied option with its command metadata option definition and pass it,
 * along with its value, to a predicate function, which is used to return a
 * subset of the parsed options.
 *
 * Options which are unknown to the command metadata are always excluded.
 *
 * @param predicate If excluded, `() => true` is used.
 */
export declare function filterCommandLineOptions<M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption>(metadata: M, parsedArgs: CommandLineOptions, predicate?: OptionPredicate<O>): CommandLineOptions;
/**
 * Given a command metadata object and an object of parsed options, return a
 * subset of the parsed options whose command metadata option definition
 * contains the supplied group(s).
 *
 * Options which are unknown to the command metadata are always excluded.
 *
 * @param groups One or more option groups.
 */
export declare function filterCommandLineOptionsByGroup<M extends CommandMetadata<I, O>, I extends CommandMetadataInput, O extends CommandMetadataOption>(metadata: M, parsedArgs: CommandLineOptions, groups: MetadataGroup | MetadataGroup[]): CommandLineOptions;
export interface UnparseArgsOptions {
    useDoubleQuotes?: boolean;
    useEquals?: boolean;
    ignoreFalse?: boolean;
    allowCamelCase?: boolean;
}
/**
 * The opposite of `parseArgs()`. This function takes parsed args and converts
 * them back into an argv array of arguments and options.
 */
export declare function unparseArgs(parsedArgs: minimist.ParsedArgs, {useDoubleQuotes, useEquals, ignoreFalse, allowCamelCase}: UnparseArgsOptions): string[];
