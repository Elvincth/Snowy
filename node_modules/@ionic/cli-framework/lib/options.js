"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const minimist = require("minimist");
const lodash = require("lodash");
exports.parseArgs = minimist;
/**
 * Remove options, which are any arguments that starts with a hyphen (-), from
 * a list of process args and return the result.
 *
 * If a double-hyphen separator (--) is encountered, it and the remaining
 * arguments are included in the result, as they are not interpreted. This
 * behavior can be disabled by setting the `includeSeparated` option to
 * `false`.
 */
function stripOptions(pargv, { includeSeparated = true }) {
    const r = /^\-/;
    const [ownArgs, otherArgs] = separateArgv(pargv);
    const filteredArgs = ownArgs.filter(arg => !r.test(arg));
    if (!includeSeparated) {
        return filteredArgs;
    }
    if (otherArgs.length > 0) {
        otherArgs.unshift('--');
    }
    return [...filteredArgs, ...otherArgs];
}
exports.stripOptions = stripOptions;
/**
 * Split a list of process args into own-arguments and other-arguments, which
 * are separated by the double-hyphen (--) separator.
 *
 * For example, `['cmd', 'arg1', '--', 'arg2']` will be split into
 * `['cmd', 'arg1']` and `['arg2']`.
 */
function separateArgv(pargv) {
    const ownArgs = [...pargv];
    const otherArgs = [];
    const sepIndex = pargv.indexOf('--');
    if (sepIndex >= 0) {
        otherArgs.push(...ownArgs.splice(sepIndex));
        otherArgs.shift(); // strip separator
    }
    return [ownArgs, otherArgs];
}
exports.separateArgv = separateArgv;
const typeDefaults = new Map()
    .set(String, null) // tslint:disable-line:no-null-keyword
    .set(Boolean, false);
/**
 * Takes a Minimist command option and normalizes its values.
 */
function hydrateCommandMetadataOption(option) {
    const type = option.type ? option.type : String;
    return lodash.assign({}, option, {
        type,
        default: option.default ? option.default : typeDefaults.get(type),
        aliases: option.aliases ? option.aliases : [],
    });
}
exports.hydrateCommandMetadataOption = hydrateCommandMetadataOption;
function metadataToParseArgsOptions(metadata) {
    const options = {
        string: ['_'],
        boolean: [],
        alias: {},
        default: {},
        '--': true,
    };
    if (!metadata.options) {
        return options;
    }
    for (const o of metadata.options) {
        const opt = hydrateCommandMetadataOption(o);
        if (opt.type === String) {
            options.string.push(opt.name);
        }
        else if (opt.type === Boolean) {
            options.boolean.push(opt.name);
        }
        options.default[opt.name] = opt.default;
        options.alias[opt.name] = opt.aliases;
    }
    return options;
}
exports.metadataToParseArgsOptions = metadataToParseArgsOptions;
var OptionFilters;
(function (OptionFilters) {
    function includesGroups(groups) {
        const g = Array.isArray(groups) ? groups : [groups];
        return (option) => typeof option.groups !== 'undefined' && lodash.intersection(option.groups, g).length > 0;
    }
    OptionFilters.includesGroups = includesGroups;
    function excludesGroups(groups) {
        const g = Array.isArray(groups) ? groups : [groups];
        return (option) => typeof option.groups === 'undefined' || lodash.difference(option.groups, g).length > 0;
    }
    OptionFilters.excludesGroups = excludesGroups;
})(OptionFilters = exports.OptionFilters || (exports.OptionFilters = {}));
/**
 * Given a command metadata object and an object of parsed options, match each
 * supplied option with its command metadata option definition and pass it,
 * along with its value, to a predicate function, which is used to return a
 * subset of the parsed options.
 *
 * Options which are unknown to the command metadata are always excluded.
 *
 * @param predicate If excluded, `() => true` is used.
 */
function filterCommandLineOptions(metadata, parsedArgs, predicate = () => true) {
    const initial = { _: parsedArgs._ };
    if (parsedArgs['--']) {
        initial['--'] = parsedArgs['--'];
    }
    const mapped = new Map(metadata.options ? [
        ...metadata.options.map((o) => [o.name, o]),
        ...lodash.flatten(metadata.options.map(opt => opt.aliases ? opt.aliases.map((a) => [a, opt]) : [])),
    ] : []);
    const pairs = Object.keys(parsedArgs)
        .map((k) => [k, mapped.get(k), parsedArgs[k]])
        .filter(([k, opt, value]) => opt && predicate(opt, value))
        .map(([k, opt, value]) => [opt ? opt.name : k, value]);
    return Object.assign({}, initial, lodash.fromPairs(pairs));
}
exports.filterCommandLineOptions = filterCommandLineOptions;
/**
 * Given a command metadata object and an object of parsed options, return a
 * subset of the parsed options whose command metadata option definition
 * contains the supplied group(s).
 *
 * Options which are unknown to the command metadata are always excluded.
 *
 * @param groups One or more option groups.
 */
function filterCommandLineOptionsByGroup(metadata, parsedArgs, groups) {
    return filterCommandLineOptions(metadata, parsedArgs, OptionFilters.includesGroups(groups));
}
exports.filterCommandLineOptionsByGroup = filterCommandLineOptionsByGroup;
/**
 * The opposite of `parseArgs()`. This function takes parsed args and converts
 * them back into an argv array of arguments and options.
 */
function unparseArgs(parsedArgs, { useDoubleQuotes, useEquals = true, ignoreFalse = true, allowCamelCase }) {
    // Based on dargs, by sindresorhus
    // @see https://github.com/sindresorhus/dargs/blob/master/license
    const args = [...parsedArgs['_'] || []];
    const separatedArgs = parsedArgs['--'];
    if (useDoubleQuotes) {
        useEquals = true;
    }
    const pushPairs = (...pairs) => {
        for (const [k, val] of pairs) {
            const key = '--' + (allowCamelCase ? k : k.replace(/[A-Z]/g, '-$&').toLowerCase());
            if (useEquals) {
                args.push(key + (val ? `=${useDoubleQuotes && val.includes(' ') ? `"${val}"` : val}` : ''));
            }
            else {
                args.push(key);
                if (val) {
                    args.push(val);
                }
            }
        }
    };
    const pairs = lodash.toPairs(parsedArgs).filter(([k]) => k !== '_' && k !== '--');
    for (const [key, val] of pairs) {
        if (val === true) {
            pushPairs([key, undefined]);
        }
        if (val === false && !ignoreFalse) {
            pushPairs([`no-${key}`, undefined]);
        }
        if (typeof val === 'string') {
            pushPairs([key, val]);
        }
        if (typeof val === 'number' && !Number.isNaN(val)) {
            pushPairs([key, val.toString()]);
        }
        if (Array.isArray(val)) {
            pushPairs(...val.map((v) => [key, v]));
        }
    }
    if (separatedArgs && separatedArgs.length > 0) {
        args.push('--', ...separatedArgs);
    }
    return args;
}
exports.unparseArgs = unparseArgs;
